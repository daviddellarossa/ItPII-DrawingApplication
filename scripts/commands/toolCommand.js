/**
 * Base class that implements the logic to perform a drawing action on the canvas.
 * Commands implement a State Machine to manage the different behaviour based on the user action during
 * the Command lifetime. The states for a particular command are generated by a [StateFactory]{@link StateFactory} unique for the command.
 *
 * Derived Classes:
 * [FreehandCommand]{@link FreehandCommand}
 * [PenCommand]{@link PenCommand}
 * [SelectionCommand]{@link SelectionCommand}
 * [ShapeCommand]{@link ShapeCommand}
 *
 */
class ToolCommand{
    /** Return the context of the command. The context is the {@link FilterManager} that provides the command with
     * the updated chain of filters. If the filter chain changes during the command's lifetime, the filter manager
     * will always serve the command with an updated chain of filters*/
    get context() { return this._context; }

    /**
     * Set the [context]{@link FilterManager} for the command
     * @param {FilterManager} value - FilterManager to set the context to.
     */
    set context(value){
        if(value instanceof FilterManager) {
            this._context = value;
        } else {
            throw new Error("value is expected to be an instance of FilterManager");
        }
    }

    /**
     * Return the State Factory for the command. This changes from command to command.
     * See {@link LcStateFactory}, {@link FcStateFactory} for more details.
     */
    get stateFactory() { return this._stateFactory; }

    /**
     * Abstract method. Return the current state for the command.
     * @abstract
     */
    get state() {throw new Error("Cannot invoke an abstract method")}

    /**
     * Set the current state for the command.
     * @param value - Current state set for the command
     * @abstract
     */
    set state(value){ throw new Error("Cannot invoke an abstract method") }

    /**
     * Create a new instance of ToolCommand
     * @param {FilterManager} context - FilterManager for the command's context
     */
    constructor(context){
        this.context = context;
        /**
         *
         * @type {StateFactory}
         * @private
         */
        this._stateFactory = null;

    }

    /**
     * Start the draw phase.
     * Notify the chain provided by the context that the draw has started.
     * Then, call the draw method on the current state
     * Finally, notify the chain that the draw has ended.
     */
    draw() {
        this.context.chain.onDrawStart();
        this.state.draw();
        this.context.chain.onDrawEnd();
    }

    /** Reset the command */
    reset(){};

    /* The following methods are invoked by the P5Instance whenever a mouse or keyboard event is raised
    * This event is propagated onto the current state for the command.
    * */
    onMlbClicked(event){
        this.state.onMlbClicked(event);
    }
    onMrbClicked(event){
        this.state.onMrbClicked(event);
    }
    onDoubleClicked(event){
        this.state.onDoubleClicked(event);
    }
    onMousePressed(event){
        this.state.onMousePressed(event);
    }
    onMouseReleased(event){
        this.state.onMouseReleased(event);
    }
    onMouseWheel(event){
        this.state.onMouseWheel(event);
    }
    onMouseMoved(event){
        this.state.onMouseMoved(event);
    }
    onMouseDragged(event){
        this.state.onMouseDragged(event);
    }
    onKeyPressed(event){
        this.state.onKeyPressed(event);
    }
    toString(){
        return `${this.constructor.name} in state ${this.state.toString()}`;
    }
    /**
     * Observer for the newTipAvailable event
     * @type {function(string)}
     */
    newTipAvailableObserver = null;
    /**
     * Observer for the onBeforeCommitAction event
     * @type {function}
     */
    onBeforeCommitActionObserver = null;
    /**
     *
     * @type {function}
     */
    onAfterCommitActionObserver = null;

    /**
     * Trigger a onBeforeCommitAction event
     */
    onBeforeCommitAction(){
        if(this.onBeforeCommitActionObserver)
            this.onBeforeCommitActionObserver();
    }

    /**
     * Trigger a onAfterCommitAction event
     */
    onAfterCommitAction(){
        if(this.onAfterCommitActionObserver)
            this.onAfterCommitActionObserver();
    }

    /**
     *
     * @return {string}
     */
    get currentTip(){ return this.state.tip; };

}
